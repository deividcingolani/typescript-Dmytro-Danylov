"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _load = _interopRequireDefault(require("@commitlint/load"));

var _throat = _interopRequireDefault(require("throat"));

var _format = _interopRequireDefault(require("./library/format"));

var _getHasName = _interopRequireDefault(require("./library/get-has-name"));

var _getPrompt = _interopRequireDefault(require("./library/get-prompt"));

var _settings = _interopRequireDefault(require("./settings"));

var _default = input;
/**
 * Get user input by interactive prompt based on
 * conventional-changelog-lint rules.
 * @param {function} prompter
 * @return {Promise<string>} commit message
 */

exports.default = _default;

function input(prompter) {
  return new Promise(function ($return, $error) {
    let results, _ref, rules;

    results = {
      type: null,
      scope: null,
      subject: null,
      body: null,
      footer: null
    };
    return Promise.resolve((0, _load.default)()).then(function ($await_1) {
      try {
        _ref = $await_1, rules = _ref.rules;
        return Promise.resolve(Promise.all(['type', 'scope', 'subject', 'body', 'footer'].map((0, _throat.default)(1, input => new Promise(function ($return, $error) {
          let inputRules, inputSettings, isHeader, headerLengthRule;
          inputRules = getRules(input, rules);
          inputSettings = _settings.default[input];
          isHeader = ['type', 'scope', 'subject'].indexOf(input) > -1;
          headerLengthRule = getRules('header', rules).filter((0, _getHasName.default)('max-length'))[0];

          if (isHeader && headerLengthRule) {
            let _headerLengthRule, _headerLengthRule$, severity, applicable, length;

            _headerLengthRule = (0, _slicedToArray2.default)(headerLengthRule, 2), _headerLengthRule$ = (0, _slicedToArray2.default)(_headerLengthRule[1], 3), severity = _headerLengthRule$[0], applicable = _headerLengthRule$[1], length = _headerLengthRule$[2];

            if (severity > 0 && applicable === 'always') {
              inputSettings.header = {
                length
              };
            }
          }

          return Promise.resolve((0, _getPrompt.default)(input, {
            rules: inputRules,
            settings: inputSettings,
            results,
            prompter
          })).then(function ($await_2) {
            try {
              results[input] = $await_2;
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        })))).catch(err => {
          console.error(err);
          return '';
        })).then(function ($await_3) {
          try {
            // Return the results
            return $return((0, _format.default)(results));
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}
/**
 * Get prefix for a given rule id
 * @param  {string} id of the rule
 * @return {string} prefix of the rule
 */


function getRulePrefix(id) {
  const fragments = id.split('-');

  const _fragments = (0, _slicedToArray2.default)(fragments, 1),
        prefix = _fragments[0];

  return fragments.length > 1 ? prefix : null;
}
/**
 * Get a predecate matching rule definitions with a given prefix
 * @param  {[type]} name [description]
 * @return {[type]}      [description]
 */


function getHasPrefix(name) {
  return rule => getRulePrefix(rule[0]) === name;
}
/**
 * Get rules for a given prefix
 * @param  {string} prefix to search in rule names
 * @param  {object} rules  rules to search in
 * @return {object}        rules matching the prefix search
 */


function getRules(prefix, rules) {
  return Object.entries(rules).filter(getHasPrefix(prefix));
}
//# sourceMappingURL=input.js.map