"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _chalk = _interopRequireDefault(require("chalk"));

var _enumRuleIsActive = _interopRequireDefault(require("./enum-rule-is-active"));

var _format = _interopRequireDefault(require("./format"));

var _getForcedCaseFn = _interopRequireDefault(require("./get-forced-case-fn"));

var _getForcedLeadingFn = _interopRequireDefault(require("./get-forced-leading-fn"));

var _getHasName = _interopRequireDefault(require("./get-has-name"));

var _meta = _interopRequireDefault(require("./meta"));

var _default = getPrompt;
/**
 * Get a cli prompt based on rule configuration
 * @param  {string} type     type of the data to gather
 * @param  {object} context     rules to parse
 * @return {object}          prompt instance
 */

exports.default = _default;

function getPrompt(type, context = {}) {
  const _context$rules = context.rules,
        rules = _context$rules === void 0 ? [] : _context$rules,
        _context$settings = context.settings,
        settings = _context$settings === void 0 ? {} : _context$settings,
        _context$results = context.results,
        results = _context$results === void 0 ? {} : _context$results,
        prompter = context.prompter;

  if (typeof prompter !== 'function') {
    throw new TypeError('Missing prompter function in getPrompt context');
  }

  const prompt = prompter();

  if (typeof prompt.removeAllListeners !== 'function') {
    throw new TypeError('getPrompt: prompt.removeAllListeners is not a function');
  }

  if (typeof prompt.command !== 'function') {
    throw new TypeError('getPrompt: prompt.command is not a function');
  }

  if (typeof prompt.catch !== 'function') {
    throw new TypeError('getPrompt: prompt.catch is not a function');
  }

  if (typeof prompt.addListener !== 'function') {
    throw new TypeError('getPrompt: prompt.addListener is not a function');
  }

  if (typeof prompt.log !== 'function') {
    throw new TypeError('getPrompt: prompt.log is not a function');
  }

  if (typeof prompt.delimiter !== 'function') {
    throw new TypeError('getPrompt: prompt.delimiter is not a function');
  }

  if (typeof prompt.show !== 'function') {
    throw new TypeError('getPrompt: prompt.show is not a function');
  }

  const enumRule = rules.filter((0, _getHasName.default)('enum')).filter(_enumRuleIsActive.default)[0];
  const emptyRule = rules.filter((0, _getHasName.default)('empty'))[0];
  const mustBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'always' : false;
  const mayNotBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'never' : false;
  const mayBeEmpty = !mayNotBeEmpty;

  if (mustBeEmpty) {
    prompt.removeAllListeners('keypress');
    prompt.removeAllListeners('client_prompt_submit');
    prompt.ui.redraw.done();
    return Promise.resolve();
  }

  const caseRule = rules.filter((0, _getHasName.default)('case'))[0];
  const forceCaseFn = (0, _getForcedCaseFn.default)(caseRule);
  const leadingBlankRule = rules.filter((0, _getHasName.default)('leading-blank'))[0];
  const forceLeadingBlankFn = (0, _getForcedLeadingFn.default)(leadingBlankRule);
  const maxLenghtRule = rules.filter((0, _getHasName.default)('max-length'))[0];
  const hasMaxLength = maxLenghtRule && maxLenghtRule[1][0] > 0;
  const inputMaxLength = hasMaxLength ? maxLenghtRule[1][1] : Infinity;
  const headerLength = settings.header ? settings.header.length : Infinity;
  const remainingHeaderLength = headerLength ? headerLength - [results.type, results.scope, results.scope ? '()' : '', results.type && results.scope ? ':' : '', results.subject].join('').length : Infinity;
  const maxLength = Math.min(inputMaxLength, remainingHeaderLength);
  return new Promise(resolve => {
    // Add the defined enums as sub commands if applicable
    if (enumRule) {
      const _enumRule = (0, _slicedToArray2.default)(enumRule, 2),
            _enumRule$ = (0, _slicedToArray2.default)(_enumRule[1], 3),
            enums = _enumRule$[2];

      enums.forEach(enumerable => {
        const enumSettings = (settings.enumerables || {})[enumerable] || {};
        prompt.command(enumerable).description(enumSettings.description || '').action(() => {
          prompt.removeAllListeners();
          prompt.ui.redraw.done();
          return resolve(forceLeadingBlankFn(forceCaseFn(enumerable)));
        });
      });
    } else {
      prompt.catch('[text...]').action(parameters => {
        const _parameters$text = parameters.text,
              text = _parameters$text === void 0 ? '' : _parameters$text;
        prompt.removeAllListeners();
        prompt.ui.redraw.done();
        return resolve(forceLeadingBlankFn(forceCaseFn(text.join(' '))));
      });
    }

    if (mayBeEmpty) {
      // Add an easy exit command
      prompt.command(':skip').description('Skip the input if possible.').action(() => {
        prompt.removeAllListeners();
        prompt.ui.redraw.done();
        resolve('');
      });
    } // Handle empty input


    const onSubmit = input => {
      if (input.length > 0) {
        return;
      } // Show help if enum is defined and input may not be empty


      if (mayNotBeEmpty) {
        prompt.ui.log(_chalk.default.yellow(`⚠ ${_chalk.default.bold(type)} may not be empty.`));
      }

      if (mayBeEmpty) {
        prompt.ui.log(_chalk.default.blue(`ℹ Enter ${_chalk.default.bold(':skip')} to omit ${_chalk.default.bold(type)}.`));
      }

      if (enumRule) {
        prompt.exec('help');
      }
    };

    const drawRemaining = length => {
      if (length < Infinity) {
        const colors = [{
          threshold: 5,
          color: 'red'
        }, {
          threshold: 10,
          color: 'yellow'
        }, {
          threshold: Infinity,
          color: 'grey'
        }];
        const color = colors.filter(item => {
          return item.threshold >= length;
        }).map(item => item.color)[0];
        prompt.ui.redraw(_chalk.default[color](`${length} characters left`));
      }
    };

    const onKey = event => {
      const sanitized = forceCaseFn(event.value);
      const cropped = sanitized.slice(0, maxLength); // We **could** do live editing, but there are some quirks to solve

      /* const live = merge({}, results, {
      	[type]: cropped
      });
      prompt.ui.redraw(`\n\n${format(live, true)}\n\n`); */

      if (maxLength) {
        drawRemaining(maxLength - cropped.length);
      }

      prompt.ui.input(cropped);
    };

    prompt.addListener('keypress', onKey);
    prompt.addListener('client_prompt_submit', onSubmit);
    prompt.log(`\n\nPlease enter a ${_chalk.default.bold(type)}: ${(0, _meta.default)({
      optional: !mayNotBeEmpty,
      required: mayNotBeEmpty,
      'tab-completion': typeof enumRule !== 'undefined',
      header: typeof settings.header !== 'undefined',
      'multi-line': settings.multiline
    })}`);

    if (settings.description) {
      prompt.log(_chalk.default.grey(`${settings.description}\n`));
    }

    prompt.log(`\n\n${(0, _format.default)(results, true)}\n\n`);
    drawRemaining(maxLength);
    prompt.delimiter(`❯ ${type}:`).show();
  });
}
//# sourceMappingURL=get-prompt.js.map